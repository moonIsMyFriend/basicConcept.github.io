---
layout: post
read_time: true
show_date: true
title:  Planning
date:   2024-09-29
description: Planning
img: posts/20210312/nnet_optimization.jpg
tags: [RL, coding]
author: 
github:  
mathjax: yes
---

##  1. 작은 문제, MDP를 안다.
- 작은 문제: 상태 집합 S나 액션의 집합A의 크기가 작음
- Planning: MDP에 대한 보상함수와 전이 확률을 알고 작은 문제인 경우 이를 이용하여 정책을 개선해 나가는 과정
- 테이블 기반 방법론(tabular method): 모든 상태 혹은 상태와 액션의 페어에 대한 테이블을 만들어서 값을 업데이트하는 방식
- 귀납(induction): 구체적 사실에서 보편적 사실을 추론
- 연역(deduction): 전체로 부터 결론을 도출

### (1) Predication
- 반복적 정책 평가(iterative policy evaluation): 테이블의 값들을 초기화한 후, 벨만 기대 방정식을 반복적으로 사용하여 테이블의 값을 조금씩 갱신하는 방법

### (2) Control (최고의 정책 찾기)
- 정책 이터레이션: 정책 평가와 정책 개선을 번갈아가며 정책이 수렴할 때까지 반복하는 방법론. 최고의 정책을 찾는 것이 목적이므로 정확한 가치를 평가는 것이 목적이 아님.
- 밸류 이터레이션: 최적 정책을 따랐을 때 나오는 최적 밸류에 초점. 벨만 최적 방정식을 이용.

## 2. 작은 문제, MDP 모름 -> 정책 평가
- 모델 프리: 액션을 취하기 전에는 보상도 액션에 대한 확률 분포도 모름
- 테이블 룩업: 테이블에 값을 기록하며 조금씩 갱신하는 방식
- 대수의 법칙(Law of large numbers, LLN): 경험을 통해 더 많은 에피소드를 진행할수록 각 상태의 밸류 예측치가 점점 정확해짐.
- Episodic MDP: 바둑, 스타크레프트 등 종료 조건이 명확한 경우
- Non-Episodic MDP: 주식처럼 에피소드가 무한히 이어지는 경우

(1) 몬테카를로 학습(MC)
- 직접 측정하기 어려운 통계량을 샘플링을 통해 그 값을 가늠하는 기법(ex: MCTS, MCMC 등)
- s를 총 몇번 방문했는지를 세는 N과 리턴의 총합V를 기록해 나가서 최종적으로 모든 상태에 대해 V/N을 하면 밸류에 대한 근사치가 나옴.
- 이론적 배경: $v_\pi(s_t)=E_\pi[G_t]$ 식에서 리턴의 기대값이기 때문에 리턴이 많이 모일수록 그 평균은 통계학에서 말하는 불편 추정량에 의해서 가치V에 수렴하게 됨.
- 단점: 업데이트를 하려면 에피소드가 끝날 때까지 기다려야 함. 종료하는 MDP에서만 사용가능.
- 단점2: TD는 긴 여정을 잘게 쪼개서 변동성이 적고, 분산이 작지만 MC는 수많은 확률적 결과로 이루어져 평균으로부터 각각의 값이 멀리 퍼질 수 있다.


(2) Temporal difference(TD)
- 미래의 추측으로 과거의 추측을 업데이트.
- 벨만 기대 방정식 $v_\pi(s_t)=E_\pi[r_{t+1}+\gamma v_\pi(s_{t+1})]$ 에서 $r_{t+1}+\gamma v_\pi(s_{t+1})$는 TD 타깃(목표치)라고 함. TD 타깃을 여러 개 모으면서 업데이트하면 실제 가치함수에 근사함.
- 단점: 현재의 추측치를 다음 스템의 추측치로 업데이트해주기 때문에 샘플을 무한히 모아서 지속적으로 업데이트해도실제 가치에 다가가리라는 보장이 없다.
- n 스텝 TD: 한 스텝만으로 평가하지 않음.(n =1 인 경우 TD-zero, n이 무한이면 MC) 
- A3C 알고리즘이 n 스텝 리턴 이용

> Asynchronous Methods for Deep Learning (2016)


## 3. MDP 모름 -> 정책 찾기
(1) 몬테카를로 컨트롤  
몬테카를로 방법론을 이용하여 정책 평가 단계에서 q를 구하고 (벨만 기대방정식 2단계 수식 사용안해도 상태의 밸류를 평가 가능해짐)
정책 개선 단계에서는 V 대신 Q를 이용하여 정책을 만들어 액션의 밸류가 높은 것을 선택
- 에이전트가 다양한 공간을 탐색(exploration)할 수 있도록 보장해주는 장치가 필요하므로 $\epsilon$-greedy (엡실론 그리디)를 이용
- $\epsilon$-greedy (엡실론 그리디): $\epsilon$이라는 작은 확률로 랜덤하게 액션을 선택하고 1- $\epsilon$ 만큼 나머지 확률로 원래의 그리디 액션을 선택.  
- decaying $\epsilon$-greedy: $\epsilon$의 값을 처음에 높게 하다가 점점 줄여주는 것이 더 좋음.

(2) SARSA   
정책 평가에서 MC대신에 TD를 사용. 샘플/스텝/트랜지션 하나만 생기면 바로 업데이트함.
- 트랜지션: 상태 전이 1번. 상태 s에서 a를 해서 보상 r을 바고 상태 $s'$에 도달하면 하나의 트랜지션.
- 벨말 기대 방정식

(3) Q 러닝
- 타깃 정책: 강화하고자 하는 목표가 되는 정책
- 행동 정책: 실제로 환경과 상호 작용하며 경험을 쌓고 있는 정책
- On-Policy: 타깃 정책과 행동 정책이 같음(직접 경험)
- Off-Policy: 타깃 정책과 행동 정책이 다름(간접 경험)
- 장점: 과거의 경험을 재사용. 사람의 데이터로부터 학습가능.
- 동시에 여러개의 정책을 학습시키는 경우 이중에서 1개의 정책만 경험을 쌓게 두고, 그로부터 생성된 데이터를 이용해 동시에 여러 개의 정책을 학습시킬 수 있다. 반대로 동시에 여러 개의 정책이 겪은 데이터를 모아서 1개의 정책으로 업데이트 할 수 있다.
- 벨만 최적 방정식을 이용하기 때문에 정책과 관련된 항이 사라짐. 해당 환경에서 존재하는 이 세상 모든 정책 중에서 "최적의 정책"에 대한 식이다. 최적 정책은 환경에 의존적이므로 환경이 정해지면 그에 따라 최적의 정책도 정해짐. 따라서 환경을 충분히 잘 탐험한다면 최적 정책을 찾게되고 여기서 환경을 탐험하는데 사용하는 정책은 어떤 정책이든 무관.

> human-level control through deep reinforcement learning (2015)


- 경사하강법(gradient descent): 그라디언트를 계산하여 파라미터를 업데이트하는 방식으로 목적함수를 최소화 해나가는 과정.

